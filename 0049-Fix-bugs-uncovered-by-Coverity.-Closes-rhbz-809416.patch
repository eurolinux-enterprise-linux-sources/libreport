From 4ce8992649aabc2b31d235e39b8fe666f671f8d9 Mon Sep 17 00:00:00 2001
From: Denys Vlasenko <vda.linux@googlemail.com>
Date: Thu, 2 Aug 2012 15:04:28 +0200
Subject: [PATCH 49/53] Fix bugs uncovered by Coverity. Closes rhbz#809416

Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
---
 src/cli/cli-report.c         |  6 +++---
 src/lib/event_xml_parser.c   | 48 ++++++++++++++++++++++++++++----------------
 src/lib/user_settings.c      | 12 +++++------
 src/plugins/reporter-print.c |  9 ---------
 src/plugins/rhbz.c           | 19 +++++++-----------
 5 files changed, 47 insertions(+), 47 deletions(-)

diff --git a/src/cli/cli-report.c b/src/cli/cli-report.c
index 33f08d1..1e13a38 100644
--- a/src/cli/cli-report.c
+++ b/src/cli/cli-report.c
@@ -341,6 +341,7 @@ static int run_report_editor(problem_data_t *problem_data)
     if (fread(text, 1, size, fp) != size)
     {
         error_msg("Can't read '%s'", filename);
+        free(text);
         fclose(fp);
         return 2;
     }
@@ -648,9 +649,8 @@ GList *str_to_glist(char *str, int delim)
     while (*str)
     {
         char *end = strchrnul(str, delim);
-        char *tmp = xstrndup(str, end - str);
-        if (*tmp)
-            list = g_list_append(list, tmp);
+        if (end != str)
+            list = g_list_append(list, xstrndup(str, end - str));
 
         str = end;
         if (!*str)
diff --git a/src/lib/event_xml_parser.c b/src/lib/event_xml_parser.c
index 8223685..1d8cc1f 100644
--- a/src/lib/event_xml_parser.c
+++ b/src/lib/event_xml_parser.c
@@ -258,9 +258,10 @@ static void text(GMarkupParseContext *context,
                     VERB2 log("new label:'%s'", text_copy);
                     free(opt->eo_label);
                     opt->eo_label = text_copy;
+                    text_copy = NULL;
                 }
             }
-            return;
+            goto ret;
         }
         /*
          * we can add a separate field for the default value
@@ -273,7 +274,8 @@ static void text(GMarkupParseContext *context,
             VERB2 log("default value:'%s'", text_copy);
             free(opt->eo_value);
             opt->eo_value = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
 
         if (strcmp(inner_element, NOTE_HTML_ELEMENT) == 0)
@@ -289,16 +291,17 @@ static void text(GMarkupParseContext *context,
                     VERB2 log("html note:'%s'", text_copy);
                     free(opt->eo_note_html);
                     opt->eo_note_html = text_copy;
+                    text_copy = NULL;
                 }
             }
-            return;
+            goto ret;
         }
 
         if (strcmp(inner_element, ALLOW_EMPTY_ELEMENT) == 0)
         {
             VERB2 log("allow-empty:'%s'", text_copy);
             opt->eo_allow_empty = string_to_bool(text_copy);
-            return;
+            goto ret;
         }
         /*
         if (strcmp(inner_element, DESCRIPTION_ELEMENT) == 0)
@@ -306,7 +309,8 @@ static void text(GMarkupParseContext *context,
             VERB2 log("tooltip:'%s'", text_copy);
             free(opt->eo_description);
             opt->eo_description = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         */
     }
@@ -319,7 +323,8 @@ static void text(GMarkupParseContext *context,
             VERB2 log("action description:'%s'", text_copy);
             free(ui->action);
             ui->action = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         */
         if (strcmp(inner_element, CREATES_ELEMENT) == 0)
@@ -327,7 +332,8 @@ static void text(GMarkupParseContext *context,
             VERB2 log("ec_creates_items:'%s'", text_copy);
             free(ui->ec_creates_items);
             ui->ec_creates_items = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         if (strcmp(inner_element, NAME_ELEMENT) == 0)
         {
@@ -342,9 +348,10 @@ static void text(GMarkupParseContext *context,
                     VERB2 log("event name:'%s'", text_copy);
                     free(ui->screen_name);
                     ui->screen_name = text_copy;
+                    text_copy = NULL;
                 }
             }
-            return;
+            goto ret;
         }
         if (strcmp(inner_element, DESCRIPTION_ELEMENT) == 0)
         {
@@ -360,9 +367,10 @@ static void text(GMarkupParseContext *context,
                 ) {
                     free(ui->description);
                     ui->description = text_copy;
+                    text_copy = NULL;
                 }
             }
-            return;
+            goto ret;
         }
         if (strcmp(inner_element, LONG_DESCR_ELEMENT) == 0)
         {
@@ -378,39 +386,43 @@ static void text(GMarkupParseContext *context,
                 ) {
                     free(ui->long_descr);
                     ui->long_descr = text_copy;
+                    text_copy = NULL;
                 }
             }
-            return;
+            goto ret;
         }
         if (strcmp(inner_element, REQUIRES_ELEMENT) == 0)
         {
             free(ui->ec_requires_items);
             ui->ec_requires_items = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         if (strcmp(inner_element, EXCL_BY_DEFAULT_ELEMENT) == 0)
         {
             free(ui->ec_exclude_items_by_default);
             ui->ec_exclude_items_by_default = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         if (strcmp(inner_element, INCL_BY_DEFAULT_ELEMENT) == 0)
         {
             free(ui->ec_include_items_by_default);
             ui->ec_include_items_by_default = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         if (strcmp(inner_element, EXCL_ALWAYS_ELEMENT) == 0)
         {
             free(ui->ec_exclude_items_always);
             ui->ec_exclude_items_always = text_copy;
-            return;
+            text_copy = NULL;
+            goto ret;
         }
         if (strcmp(inner_element, EXCL_BINARY_ELEMENT) == 0)
         {
             ui->ec_exclude_binary_items = string_to_bool(text_copy);
-            free(text_copy);
-            return;
+            goto ret;
         }
         if (strcmp(inner_element, MINIMAL_RATING_ELEMENT) == 0)
         {
@@ -422,9 +434,11 @@ static void text(GMarkupParseContext *context,
                 log("invalid minimal-rating number '%s', set to default 4", text_copy);
                 ui->ec_minimal_rating = 4;
             }
-            return;
+            goto ret;
         }
     }
+
+ ret:
     free(text_copy);
 }
 
diff --git a/src/lib/user_settings.c b/src/lib/user_settings.c
index 827c830..d3469d2 100644
--- a/src/lib/user_settings.c
+++ b/src/lib/user_settings.c
@@ -42,15 +42,18 @@ static bool create_parentdir(char *path)
 bool save_conf_file(const char *path, map_string_h *settings)
 {
     bool ret;
-    FILE *out;
     char *temp_path, *name, *value;
     GHashTableIter iter;
 
-    ret = false, out = NULL;
+    ret = false;
 
     temp_path = xasprintf("%s.tmp", path);
 
-    if (!create_parentdir(temp_path) || !(out = fopen(temp_path, "w")))
+    if (!create_parentdir(temp_path))
+        goto cleanup;
+
+    FILE *out = fopen(temp_path, "w");
+    if (!out)
         goto cleanup;
 
     g_hash_table_iter_init(&iter, settings);
@@ -58,7 +61,6 @@ bool save_conf_file(const char *path, map_string_h *settings)
         fprintf(out, "%s = \"%s\"\n", name, value);
 
     fclose(out);
-    out = NULL;
 
     if (!rename(temp_path, path))
         goto cleanup;
@@ -66,8 +68,6 @@ bool save_conf_file(const char *path, map_string_h *settings)
     ret = true; /* success */
 
 cleanup:
-    if (out)
-        fclose(out);
     free(temp_path);
 
     return ret;
diff --git a/src/plugins/reporter-print.c b/src/plugins/reporter-print.c
index e7f6c3d..ec0c5bb 100644
--- a/src/plugins/reporter-print.c
+++ b/src/plugins/reporter-print.c
@@ -98,15 +98,6 @@ int main(int argc, char **argv)
                 output_file = strtrim(response);
             }
 
-            /* do not allow symlinks (this can be an attack) */
-            struct stat stbuf;
-            if (lstat(output_file, &stbuf) == 0 && S_ISLNK(stbuf.st_mode))
-            {
-                msg = xasprintf(_("File '%s' is a symbolic link. "
-                                  "Please select a regular file:"), output_file);
-                continue;
-            }
-
             FILE *outstream = fopen(output_file, open_mode);
             if (!outstream)
             {
diff --git a/src/plugins/rhbz.c b/src/plugins/rhbz.c
index 8b69494..b47edac 100644
--- a/src/plugins/rhbz.c
+++ b/src/plugins/rhbz.c
@@ -115,7 +115,7 @@ int is_comment_dup(GList *comments, const char *comment)
     {
         const char * const comment_body = (const char *) l->data;
         char * const trim_comment_body = trim_all_whitespace(comment_body);
-        same_comments = !strcmp(trim_comment_body, trim_comment);
+        same_comments = (strcmp(trim_comment_body, trim_comment) == 0);
         free(trim_comment_body);
     }
 
@@ -144,24 +144,19 @@ static unsigned find_best_bt_rating_in_comments(GList *comments)
         }
 
         start_rating_line += strlen(FILENAME_RATING": ");
-        char *end_rating_line = strchr(start_rating_line, '\n');
-        if (!end_rating_line)
-            VERB3 error_msg("broken comment body");
 
-        char *rating_srt = xstrndup(start_rating_line, end_rating_line - start_rating_line);
-        int old_errno = errno;
         errno = 0;
         char *e;
-        long rating = strtoul(rating_srt, &e, 10);
-        if (errno || rating_srt == e || *e != '\0' || rating > UINT_MAX)
+        long rating = strtoul(start_rating_line, &e, 10);
+        /*
+         * Note: we intentionally check for '\n'. Any other terminator
+         * (even '\0') is not ok in this case.
+         */
+        if (errno || e == start_rating_line || *e != '\n' || (unsigned long)rating > UINT_MAX)
         {
             /* error / no digits / illegal trailing chars */
-            errno = old_errno;
-            free(rating_srt);
             continue;
         }
-        errno = old_errno; /* Ok.  So restore errno. */
-        free(rating_srt);
 
         if (rating > best_bt_rating)
             best_bt_rating = rating;
-- 
1.7.11.2

