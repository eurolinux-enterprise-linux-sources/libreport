From 0683f4d02922daa42bc57755911fcfc9448e5eba Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Fri, 25 Apr 2014 13:01:13 +0200
Subject: [LIBREPORT PATCH 110/111] Bugzilla: pass Bugzilla_token in all XML
 RPC calls

Introduce the session parameters for XML RPC calls. These parameters are
added to every XML RPC call.

abrt_xmlrpc_call*() functions expected formatting string in form of
"({...})" for some good but unknown reason. Since now, the functions
expects formatting string without the outer brackets.

() - means empty array (allowed in xmlrpc-c)
{} - means empty structure (allowed in xmlrpc-c)

Cite:

Instead of returning a cookie, the User.login call now returns a token
that clients must pass in the Bugzilla_token parameter to subsequent
RPC calls. If the token is not passed, Bugzilla will treat the RPC
call as unauthenticated and will not allow access to non-public data.

See
https://partner-bugzilla.redhat.com/docs/en/html/api/Bugzilla/WebService.html#LOGGING_IN
for more details.

Client scripts that access Red Hat Bugzilla via XML-RPC or JSON-RPC
and use login cookies for authentication must be updated to instead
remember the token received when logging in and pass that token back
to Bugzilla in subsequent RPC calls.

[http://post-office.corp.redhat.com/archives/bugzilla-list/2014-April/msg00005.html]

Resolves rhbz#1090466

Signed-off-by: Jakub Filak <jfilak@redhat.com>
---
 src/lib/abrt_xmlrpc.c | 131 ++++++++++++++++++++++++++++++++++++++++++++------
 src/lib/abrt_xmlrpc.h |   7 +++
 src/plugins/rhbz.c    |  30 ++++++++----
 3 files changed, 143 insertions(+), 25 deletions(-)

diff --git a/src/lib/abrt_xmlrpc.c b/src/lib/abrt_xmlrpc.c
index 74e473e..cf132f5 100644
--- a/src/lib/abrt_xmlrpc.c
+++ b/src/lib/abrt_xmlrpc.c
@@ -20,6 +20,12 @@
 #include "abrt_xmlrpc.h"
 #include "proxies.h"
 
+struct abrt_xmlrpc_param_pair
+{
+    char *name;
+    xmlrpc_value *value;
+};
+
 void abrt_xmlrpc_die(xmlrpc_env *env)
 {
     error_msg_and_die("fatal: %s", env->fault_string);
@@ -105,40 +111,135 @@ void abrt_xmlrpc_free_client(struct abrt_xmlrpc *ax)
     if (ax->ax_client)
         xmlrpc_client_destroy(ax->ax_client);
 
+    for (GList *iter = ax->ax_session_params; iter; iter = g_list_next(iter))
+    {
+        struct abrt_xmlrpc_param_pair *param_pair = (struct abrt_xmlrpc_param_pair *)iter->data;
+        xmlrpc_DECREF(param_pair->value);
+        free(param_pair->name);
+        free(param_pair);
+    }
+
+    g_list_free(ax->ax_session_params);
+
     free(ax);
 }
 
-/* die or return expected results */
-xmlrpc_value *abrt_xmlrpc_call(struct abrt_xmlrpc *ax,
-                               const char* method, const char* format, ...)
+void abrt_xmlrpc_client_add_session_param_string(xmlrpc_env *env, struct abrt_xmlrpc *ax,
+        const char *name, const char *value)
 {
-    xmlrpc_env env;
-    xmlrpc_env_init(&env);
+    struct abrt_xmlrpc_param_pair *new_ses_param = xmalloc(sizeof(*new_ses_param));
+    new_ses_param->name = xstrdup(name);
+
+    new_ses_param->value = xmlrpc_string_new(env, value);
+    if (env->fault_occurred)
+        abrt_xmlrpc_die(env);
+
+    ax->ax_session_params = g_list_append(ax->ax_session_params, new_ses_param);
+}
+
+/* internal helper function */
+static xmlrpc_value *abrt_xmlrpc_call_params_internal(xmlrpc_env *env, struct abrt_xmlrpc *ax, const char *method, xmlrpc_value *params)
+{
+    bool destroy_params = false;
+    if (xmlrpc_value_type(params) == XMLRPC_TYPE_NIL)
+    {
+        destroy_params = true;
+        params = abrt_xmlrpc_params_new(env);
+    }
+
+    if (xmlrpc_value_type(params) == XMLRPC_TYPE_STRUCT)
+    {
+        for (GList *iter = ax->ax_session_params; iter; iter = g_list_next(iter))
+        {
+            struct abrt_xmlrpc_param_pair *param_pair = (struct abrt_xmlrpc_param_pair *)iter->data;
+
+            xmlrpc_struct_set_value(env, params, param_pair->name, param_pair->value);
+            if (env->fault_occurred)
+                abrt_xmlrpc_die(env);
+        }
+    }
+    else
+    {
+        log("Bug: not yet supported XML RPC call type: argument type = '%s'", xmlrpc_type_name(xmlrpc_value_type(params)));
+    }
+
+    xmlrpc_value *array = abrt_xmlrpc_array_new(env);
+    xmlrpc_array_append_item(env, array, params);
+    if (env->fault_occurred)
+        abrt_xmlrpc_die(env);
+
+    xmlrpc_value *result = NULL;
+    xmlrpc_client_call2(env, ax->ax_client, ax->ax_server_info, method,
+                        array, &result);
+
+    xmlrpc_DECREF(array);
+
+    if (destroy_params)
+        xmlrpc_DECREF(params);
+
+    return result;
+}
 
+/* internal helper function */
+static
+xmlrpc_value *abrt_xmlrpc_call_full_va(xmlrpc_env *env, struct abrt_xmlrpc *ax,
+                                       const char *method, const char *format,
+                                       va_list args)
+{
     xmlrpc_value* param = NULL;
     const char* suffix;
-    va_list args;
 
-    va_start(args, format);
-    xmlrpc_build_value_va(&env, format, args, &param, &suffix);
+    xmlrpc_build_value_va(env, format, args, &param, &suffix);
     va_end(args);
-    if (env.fault_occurred)
-        abrt_xmlrpc_die(&env);
+    if (env->fault_occurred)
+        abrt_xmlrpc_die(env);
 
     xmlrpc_value* result = NULL;
     if (*suffix != '\0')
     {
         xmlrpc_env_set_fault_formatted(
-            &env, XMLRPC_INTERNAL_ERROR, "Junk after the argument "
+            env, XMLRPC_INTERNAL_ERROR, "Junk after the argument "
             "specifier: '%s'.  There must be exactly one argument.",
             suffix);
     }
     else
-    {
-        xmlrpc_client_call2(&env, ax->ax_client, ax->ax_server_info, method,
-                            param, &result);
-    }
+        result = abrt_xmlrpc_call_params_internal(env, ax, method, param);
+
     xmlrpc_DECREF(param);
+
+    return result;
+}
+
+xmlrpc_value *abrt_xmlrpc_array_new(xmlrpc_env *env)
+{
+    xmlrpc_value *params = xmlrpc_array_new(env);
+    if (env->fault_occurred)
+        abrt_xmlrpc_die(env);
+
+    return params;
+}
+
+xmlrpc_value *abrt_xmlrpc_params_new(xmlrpc_env *env)
+{
+    xmlrpc_value *params = xmlrpc_struct_new(env);
+    if (env->fault_occurred)
+        abrt_xmlrpc_die(env);
+
+    return params;
+}
+
+/* die or return expected results */
+xmlrpc_value *abrt_xmlrpc_call(struct abrt_xmlrpc *ax,
+                               const char *method, const char *format, ...)
+{
+    xmlrpc_env env;
+    xmlrpc_env_init(&env);
+
+    va_list args;
+    va_start(args, format);
+    xmlrpc_value *result = abrt_xmlrpc_call_full_va(&env, ax, method, format, args);
+    va_end(args);
+
     if (env.fault_occurred)
         abrt_xmlrpc_die(&env);
 
diff --git a/src/lib/abrt_xmlrpc.h b/src/lib/abrt_xmlrpc.h
index 5c94360..3cb0e77 100644
--- a/src/lib/abrt_xmlrpc.h
+++ b/src/lib/abrt_xmlrpc.h
@@ -23,6 +23,7 @@
  * include/xmlrpc-c/base.h: typedef int32_t xmlrpc_int32;
  */
 
+#include <glib.h>
 #include <xmlrpc-c/base.h>
 #include <xmlrpc-c/client.h>
 
@@ -33,10 +34,16 @@ extern "C" {
 struct abrt_xmlrpc {
     xmlrpc_client *ax_client;
     xmlrpc_server_info *ax_server_info;
+    GList *ax_session_params;
 };
 
+xmlrpc_value *abrt_xmlrpc_array_new(xmlrpc_env *env);
+
+xmlrpc_value *abrt_xmlrpc_params_new(xmlrpc_env *env);
+
 struct abrt_xmlrpc *abrt_xmlrpc_new_client(const char *url, int ssl_verify);
 void abrt_xmlrpc_free_client(struct abrt_xmlrpc *ax);
+void abrt_xmlrpc_client_add_session_param_string(xmlrpc_env *env, struct abrt_xmlrpc *ax, const char *name, const char *value);
 void abrt_xmlrpc_die(xmlrpc_env *env) __attribute__((noreturn));
 void abrt_xmlrpc_error(xmlrpc_env *env);
 
diff --git a/src/plugins/rhbz.c b/src/plugins/rhbz.c
index f526eac..45d54b6 100644
--- a/src/plugins/rhbz.c
+++ b/src/plugins/rhbz.c
@@ -162,7 +162,7 @@ static GList *rhbz_comments(struct abrt_xmlrpc *ax, int bug_id)
      *           <value><array>
      * ...
      */
-    xmlrpc_value *xml_response = abrt_xmlrpc_call(ax, "Bug.comments", "({s:(i)})",
+    xmlrpc_value *xml_response = abrt_xmlrpc_call(ax, "Bug.comments", "{s:(i)}",
                                                                       "ids", bug_id);
     /* bugs
      *     This is used for bugs specified in ids. This is a hash, where the
@@ -291,9 +291,19 @@ void rhbz_login(struct abrt_xmlrpc *ax, struct bugzilla_struct *b)
 {
     func_entry();
 
-    xmlrpc_value* result = abrt_xmlrpc_call(ax, "User.login", "({s:s,s:s})",
+    xmlrpc_value* result = abrt_xmlrpc_call(ax, "User.login", "{s:s,s:s}",
                                             "login", b->b_login, "password", b->b_password);
 
+    char *token = rhbz_bug_read_item("token", result, RHBZ_READ_STR);
+    if (token != NULL)
+    {
+        VERB3 log("Adding session param Bugzilla_token");
+        xmlrpc_env env;
+        xmlrpc_env_init(&env);
+        abrt_xmlrpc_client_add_session_param_string(&env, ax, "Bugzilla_token", token);
+        free(token);
+    }
+
 //TODO: with URL like http://bugzilla.redhat.com (that is, with http: instead of https:)
 //we are getting this error:
 //Logging into Bugzilla at http://bugzilla.redhat.com
@@ -317,7 +327,7 @@ xmlrpc_value *rhbz_search_duphash(struct abrt_xmlrpc *ax, const char *component,
         strbuf_append_strf(query, " component:\"%s\"", component);
 
     VERB3 log("search for '%s'", query->buf);
-    xmlrpc_value *ret = abrt_xmlrpc_call(ax, "Bug.search", "({s:s})",
+    xmlrpc_value *ret = abrt_xmlrpc_call(ax, "Bug.search", "{s:s}",
                                          "quicksearch", query->buf);
     strbuf_free(query);
 
@@ -521,7 +531,7 @@ struct bug_info *rhbz_bug_info(struct abrt_xmlrpc *ax, int bug_id)
      *        <value><array><data>
      *        ...
      */
-    xmlrpc_value *xml_bug_response = abrt_xmlrpc_call(ax, "Bug.get", "({s:(i)})",
+    xmlrpc_value *xml_bug_response = abrt_xmlrpc_call(ax, "Bug.get", "{s:(i)}",
                                                           "ids", bug_id);
 
     xmlrpc_value *bugs_memb = rhbz_get_member("bugs", xml_bug_response);
@@ -722,7 +732,7 @@ int rhbz_new_bug(struct abrt_xmlrpc *ax, problem_data_t *problem_data,
     char *status_whiteboard = xasprintf("abrt_hash:%s", duphash);
     if (depend_on_bug > -1)
     {
-        result = abrt_xmlrpc_call(ax, "Bug.create", "({s:s,s:s,s:s,s:s,s:s,s:s,s:s,s:i})",
+        result = abrt_xmlrpc_call(ax, "Bug.create", "{s:s,s:s,s:s,s:s,s:s,s:s,s:s,s:i}",
                                   "product", product,
                                   "component", component,
                                   "version", version,
@@ -734,7 +744,7 @@ int rhbz_new_bug(struct abrt_xmlrpc *ax, problem_data_t *problem_data,
     }
     else
     {
-        result = abrt_xmlrpc_call(ax, "Bug.create", "({s:s,s:s,s:s,s:s,s:s,s:s,s:s})",
+        result = abrt_xmlrpc_call(ax, "Bug.create", "{s:s,s:s,s:s,s:s,s:s,s:s,s:s}",
                                   "product", product,
                                   "component", component,
                                   "version", version,
@@ -779,7 +789,7 @@ int rhbz_attach_blob(struct abrt_xmlrpc *ax, const char *filename,
      *   6 -> base64,  two arguments (char* plain data which will be encoded by xmlrpc-c to base64,
      *                                size_t number of bytes to encode)
      */
-    result = abrt_xmlrpc_call(ax, "Bug.add_attachment", "({s:(s),s:s,s:s,s:s,s:6,s:i})",
+    result = abrt_xmlrpc_call(ax, "Bug.add_attachment", "{s:(s),s:s,s:s,s:s,s:6,s:i}",
                 "ids", bug_id,
                 "summary", fn,
                 "file_name", filename,
@@ -914,7 +924,7 @@ void rhbz_logout(struct abrt_xmlrpc *ax)
 {
     func_entry();
 
-    xmlrpc_value* result = abrt_xmlrpc_call(ax, "User.logout", "(s)", "");
+    xmlrpc_value* result = abrt_xmlrpc_call(ax, "User.logout", "{}");
     if (result)
         xmlrpc_DECREF(result);
 }
@@ -962,7 +972,7 @@ void rhbz_mail_to_cc(struct abrt_xmlrpc *ax, int bug_id, const char *mail, int f
     );
 #endif
     /* Bugzilla 4.0+ uses this API: */
-    result = abrt_xmlrpc_call(ax, "Bug.update", "({s:i,s:{s:(s),s:i}})",
+    result = abrt_xmlrpc_call(ax, "Bug.update", "{s:i,s:{s:(s),s:i}}",
                               "ids", bug_id,
                               "cc", "add", mail,
                                     "nomail", nomail_notify
@@ -999,7 +1009,7 @@ void rhbz_add_comment(struct abrt_xmlrpc *ax, int bug_id, const char *comment,
     int nomail_notify = !!IS_NOMAIL_NOTIFY(flags);
 
     xmlrpc_value *result;
-    result = abrt_xmlrpc_call(ax, "Bug.add_comment", "({s:i,s:s,s:b,s:i})",
+    result = abrt_xmlrpc_call(ax, "Bug.add_comment", "{s:i,s:s,s:b,s:i}",
                               "id", bug_id, "comment", comment,
                               "private", private, "nomail", nomail_notify);
 
-- 
1.8.3.1

