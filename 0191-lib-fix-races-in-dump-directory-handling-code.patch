From 67899c5a5d4a5f884ac07d691be4495551ad1551 Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Fri, 24 Apr 2015 10:57:23 +0200
Subject: [LIBREPORT PATCH] lib: fix races in dump directory handling code

Florian Weimer <fweimer@redhat.com>:

    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and
    use openat() and similar functions to access files in it.

    ...

    The file system manipulation functions should guard against hard
    links (check that link count is <= 1, just as in the user coredump
    code in abrt-hook-ccpp), possibly after opening the file
    with O_PATH first to avoid side effects on open/close.

O_PATH is not available in RHEL-6

Related: #1214745

Signed-off-by: Jakub Filak <jfilak@redhat.com>
---
 src/include/dump_dir.h           |  11 +-
 src/include/internal_libreport.h |   4 +
 src/lib/dump_dir.c               | 465 +++++++++++++++++++++++++--------------
 src/lib/problem_data.c           |   6 +-
 src/lib/xfuncs.c                 |  22 +-
 5 files changed, 340 insertions(+), 168 deletions(-)

diff --git a/src/include/dump_dir.h b/src/include/dump_dir.h
index f8a262c..3655e1b 100644
--- a/src/include/dump_dir.h
+++ b/src/include/dump_dir.h
@@ -32,6 +32,13 @@
 extern "C" {
 #endif
 
+/* Utility function */
+
+/* Opens filename for reading relatively to a directory represented by dir_fd.
+ * The function fails if the file is symbolic link, directory or hard link.
+ */
+int secure_openat_read(int dir_fd, const char *filename);
+
 enum {
     DD_FAIL_QUIETLY_ENOENT = (1 << 0),
     DD_FAIL_QUIETLY_EACCES = (1 << 1),
@@ -50,8 +57,10 @@ struct dump_dir {
     int locked;
     uid_t dd_uid;
     gid_t dd_gid;
-    /* mode fo saved files */
+    /* mode of saved files */
     mode_t mode;
+    time_t dd_time;
+    int dd_fd;
 };
 
 void dd_close(struct dump_dir *dd);
diff --git a/src/include/internal_libreport.h b/src/include/internal_libreport.h
index cbf8b8c..038cb33 100644
--- a/src/include/internal_libreport.h
+++ b/src/include/internal_libreport.h
@@ -389,6 +389,8 @@ int xopen3(const char *pathname, int flags, int mode);
 int xopen(const char *pathname, int flags);
 #define xunlink libreport_xunlink
 void xunlink(const char *pathname);
+#define xunlinkat libreport_xunlinkat
+void xunlinkat(int dir_fd, const char *pathname, int flags);
 
 /* Just testing dent->d_type == DT_REG is wrong: some filesystems
  * do not report the type, they report DT_UNKNOWN for every dirent
@@ -398,6 +400,8 @@ void xunlink(const char *pathname);
  */
 #define is_regular_file libreport_is_regular_file
 int is_regular_file(struct dirent *dent, const char *dirname);
+#define is_regular_file_at libreport_is_regular_file_at
+int is_regular_file_at(struct dirent *dent, int dir_fd);
 
 #define dot_or_dotdot libreport_dot_or_dotdot
 bool dot_or_dotdot(const char *filename);
diff --git a/src/lib/dump_dir.c b/src/lib/dump_dir.c
index 622e756..7b0e258 100644
--- a/src/lib/dump_dir.c
+++ b/src/lib/dump_dir.c
@@ -85,6 +85,7 @@
 
 
 static char *load_text_file(const char *path, unsigned flags);
+static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);
 
 static bool isdigit_str(const char *str)
 {
@@ -96,10 +97,10 @@ static bool isdigit_str(const char *str)
     return true;
 }
 
-static bool exist_file_dir(const char *path)
+static bool exist_file_dir_at(int dir_fd, const char *name)
 {
     struct stat buf;
-    if (stat(path, &buf) == 0)
+    if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)
     {
         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))
         {
@@ -109,14 +110,114 @@ static bool exist_file_dir(const char *path)
     return false;
 }
 
+/* Opens the file in the following steps:
+ * 1. open the file with O_NOFOLLOW (do not dereference symbolick links)
+ * 2. stat the resulting file descriptor and fail if the opened file is not a
+ *    regular file or if the number of links is greater than 1 (that means that
+ *    the inode has more names (hard links))
+ * 3. return the fd
+ */
+int secure_openat_read(int dir_fd, const char *pathname)
+{
+    int path_fd = openat(dir_fd, pathname, O_RDONLY | O_NOFOLLOW);
+    if (path_fd < 0)
+        return -1;
+
+    struct stat path_sb;
+    int r = fstat(path_fd, &path_sb);
+    if (r < 0)
+    {
+        perror_msg("stat");
+        close(path_fd);
+        return -1;
+    }
+
+    if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)
+    {
+        VERB1 log("Path isn't a regular file or has more links (%lu)", (unsigned long)path_sb.st_nlink);
+        errno = EINVAL;
+        close(path_fd);
+        return -1;
+    }
+
+    return path_fd;
+}
+
+/* Returns value less than 0 if the file is not readable or
+ * if the file doesn't contain valid unixt time stamp.
+ *
+ * Any possible failure will be logged.
+ */
+static time_t parse_time_file_at(int dir_fd, const char *filename)
+{
+    /* Open input file, and parse it. */
+    int fd = secure_openat_read(dir_fd, filename);
+    if (fd < 0)
+    {
+        VERB2 perror_msg("Can't open '%s'", filename);
+        return -1;
+    }
+
+    /* ~ maximal number of digits for positive time stamp string */
+    char time_buf[sizeof(time_t) * 3 + 1];
+    ssize_t rdsz = read(fd, time_buf, sizeof(time_buf));
+
+    /* Just reading, so no need to check the returned value. */
+    close(fd);
+
+    if (rdsz == -1)
+    {
+        VERB2 perror_msg("Can't read from '%s'", filename);
+        return -1;
+    }
+    /* approximate maximal number of digits in timestamp is sizeof(time_t)*3 */
+    /* buffer has this size + 1 byte for trailing '\0' */
+    /* if whole size of buffer was read then file is bigger */
+    /* than string representing maximal time stamp */
+    if (rdsz == sizeof(time_buf))
+    {
+        VERB2 log("File '%s' is too long to be valid unix "
+                       "time stamp (max size %u)", filename, (int)sizeof(time_buf));
+        return -1;
+    }
+
+    /* Our tools don't put trailing newline into time file,
+     * but we allow such format too:
+     */
+    if (rdsz > 0 && time_buf[rdsz - 1] == '\n')
+        rdsz--;
+    time_buf[rdsz] = '\0';
+
+    /* Note that on some architectures (x32) time_t is "long long" */
+
+    errno = 0;    /* To distinguish success/failure after call */
+    char *endptr;
+    long long val = strtoll(time_buf, &endptr, /* base */ 10);
+    const long long MAX_TIME_T = (1ULL << (sizeof(time_t)*8 - 1)) - 1;
+
+    /* Check for various possible errors */
+    if (errno
+     || (*endptr != '\0')
+     || val >= MAX_TIME_T
+     || !isdigit_str(time_buf) /* this filters out "-num", "   num", "" */
+    ) {
+        VERB2 perror_msg("File '%s' doesn't contain valid unix "
+                        "time stamp ('%s')", filename, time_buf);
+        return -1;
+    }
+
+    /* If we got here, strtoll() successfully parsed a number */
+    return val;
+}
+
 /* Return values:
  * -1: error (in this case, errno is 0 if error message is already logged)
  *  0: failed to lock (someone else has it locked)
  *  1: success
  */
-static int get_and_set_lock(const char* lock_file, const char* pid)
+int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)
 {
-    while (symlink(pid, lock_file) != 0)
+    while (symlinkat(pid, dir_fd, lock_file) != 0)
     {
         if (errno != EEXIST)
         {
@@ -129,7 +230,7 @@ static int get_and_set_lock(const char* lock_file, const char* pid)
         }
 
         char pid_buf[sizeof(pid_t)*3 + 4];
-        ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);
+        ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);
         if (r < 0)
         {
             if (errno == ENOENT)
@@ -161,7 +262,7 @@ static int get_and_set_lock(const char* lock_file, const char* pid)
             log("Lock file '%s' was locked by process %s, but it crashed?", lock_file, pid_buf);
         }
         /* The file may be deleted by now by other process. Ignore ENOENT */
-        if (unlink(lock_file) != 0 && errno != ENOENT)
+        if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)
         {
             perror_msg("Can't remove stale lock file '%s'", lock_file);
             errno = 0;
@@ -173,6 +274,18 @@ static int get_and_set_lock(const char* lock_file, const char* pid)
     return 1;
 }
 
+static const char *dd_check(struct dump_dir *dd)
+{
+    dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);
+    if (dd->dd_time < 0)
+    {
+        VERB1 log("Missing file: "FILENAME_TIME);
+        return FILENAME_TIME;
+    }
+
+    return NULL;
+}
+
 static int dd_lock(struct dump_dir *dd, unsigned sleep_usec, int flags)
 {
     if (dd->locked)
@@ -181,16 +294,11 @@ static int dd_lock(struct dump_dir *dd, unsigned sleep_usec, int flags)
     char pid_buf[sizeof(long)*3 + 2];
     sprintf(pid_buf, "%lu", (long)getpid());
 
-    unsigned dirname_len = strlen(dd->dd_dirname);
-    char lock_buf[dirname_len + sizeof("/.lock")];
-    strcpy(lock_buf, dd->dd_dirname);
-    strcpy(lock_buf + dirname_len, "/.lock");
-
     unsigned count = NO_TIME_FILE_COUNT;
  retry:
     while (1)
     {
-        int r = get_and_set_lock(lock_buf, pid_buf);
+        int r = create_symlink_lockfile_at(dd->dd_fd, ".lock", pid_buf);
         if (r < 0)
             return r; /* error */
         if (r > 0)
@@ -202,17 +310,16 @@ static int dd_lock(struct dump_dir *dd, unsigned sleep_usec, int flags)
     /* Are we called by dd_opendir (as opposed to dd_create)? */
     if (sleep_usec == WAIT_FOR_OTHER_PROCESS_USLEEP) /* yes */
     {
-        strcpy(lock_buf + dirname_len, "/"FILENAME_TIME);
-        if (access(lock_buf, F_OK) != 0)
+        const char *missing_file = dd_check(dd);
+        if (missing_file)
         {
             /* time file doesn't exist. We managed to lock the directory
              * which was just created by somebody else, or is almost deleted
              * by delete_file_dir.
              * Unlock and back off.
              */
-            strcpy(lock_buf + dirname_len, "/.lock");
-            xunlink(lock_buf);
-            VERB1 log("Unlocked '%s' (no time file)", lock_buf);
+            xunlinkat(dd->dd_fd, ".lock", /*only files*/0);
+            VERB1 log("Unlocked '%s' (no or corrupted '%s' file)", dd->dd_dirname, missing_file);
             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)
             {
                 errno = EISDIR; /* "this is an ordinary dir, not dump dir" */
@@ -233,29 +340,26 @@ static void dd_unlock(struct dump_dir *dd)
     {
         dd->locked = 0;
 
-        unsigned dirname_len = strlen(dd->dd_dirname);
-        char lock_buf[dirname_len + sizeof("/.lock")];
-        strcpy(lock_buf, dd->dd_dirname);
-        strcpy(lock_buf + dirname_len, "/.lock");
-        xunlink(lock_buf);
+        xunlinkat(dd->dd_fd, ".lock", /*only files*/0);
 
-        VERB1 log("Unlocked '%s'", lock_buf);
+        VERB1 log("Unlocked '%s/.lock'", dd->dd_dirname);
     }
 }
 
 static inline struct dump_dir *dd_init(void)
 {
-    return (struct dump_dir*)xzalloc(sizeof(struct dump_dir));
+    struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));
+    dd->dd_time = -1;
+    dd->dd_fd = -1;
+    return dd;
 }
 
-int dd_exist(const struct dump_dir *dd, const char *path)
+int dd_exist(const struct dump_dir *dd, const char *name)
 {
-    if (!str_is_correct_filename(path))
-        error_msg_and_die("Cannot test existence. '%s' is not a valid file name", path);
+    if (!str_is_correct_filename(name))
+        error_msg_and_die("Cannot test existence. '%s' is not a valid file name", name);
 
-    char *full_path = concat_path_file(dd->dd_dirname, path);
-    int ret = exist_file_dir(full_path);
-    free(full_path);
+    const int ret = exist_file_dir_at(dd->dd_fd, name);
     return ret;
 }
 
@@ -265,6 +369,10 @@ void dd_close(struct dump_dir *dd)
         return;
 
     dd_unlock(dd);
+
+    if (dd->dd_fd >= 0)
+        close(dd->dd_fd);
+
     if (dd->next_dir)
     {
         closedir(dd->next_dir);
@@ -288,10 +396,13 @@ struct dump_dir *dd_opendir(const char *dir, int flags)
     struct dump_dir *dd = dd_init();
 
     dir = dd->dd_dirname = rm_trailing_slashes(dir);
-
+    dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);
     struct stat stat_buf;
-    if (stat(dir, &stat_buf) != 0)
+    if (dd->dd_fd < 0)
+        goto cant_access;
+    if (fstat(dd->dd_fd, &stat_buf) != 0)
         goto cant_access;
+
     /* & 0666 should remove the executable bit */
     dd->mode = (stat_buf.st_mode & 0666);
 
@@ -301,18 +412,17 @@ struct dump_dir *dd_opendir(const char *dir, int flags)
         if ((flags & DD_OPEN_READONLY) && errno == EACCES)
         {
             /* Directory is not writable. If it seems to be readable,
-             * return "read only" dd, not NULL */
-            if (stat(dir, &stat_buf) == 0
-             && S_ISDIR(stat_buf.st_mode)
-             && access(dir, R_OK) == 0
-            ) {
-                char *time_file_name = concat_path_file(dir, FILENAME_TIME);
-                if (access(time_file_name, R_OK) != 0)
+             * return "read only" dd, not NULL
+             *
+             * Does the directory have 'x' flag?
+             */
+            if (faccessat(dd->dd_fd, ".", R_OK, AT_SYMLINK_NOFOLLOW) == 0)
+            {
+                if(dd_check(dd) != NULL)
                 {
                     dd_close(dd);
                     dd = NULL;
                 }
-                free(time_file_name);
                 return dd;
             }
         }
@@ -349,10 +459,9 @@ struct dump_dir *dd_opendir(const char *dir, int flags)
     if (geteuid() == 0)
     {
         /* In case caller would want to create more files, he'll need uid:gid */
-        struct stat stat_buf;
-        if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))
+        if (fstat(dd->dd_fd, &stat_buf) != 0)
         {
-            error_msg("Can't stat '%s', or it is not a directory", dir);
+            error_msg("Can't stat '%s'", dir);
             dd_close(dd);
             return NULL;
         }
@@ -410,8 +519,7 @@ struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int
          * dd_create("dir/..") and similar are madness, refuse them.
          */
         error_msg("Bad dir name '%s'", dir);
-        dd_close(dd);
-        return NULL;
+        goto fail;
     }
 
     /* Was creating it with mode 0700 and user as the owner, but this allows
@@ -427,22 +535,31 @@ struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int
     if (r != 0)
     {
         perror_msg("Can't create directory '%s'", dir);
-        dd_close(dd);
-        return NULL;
+        goto fail;
     }
 
-    if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)
+    dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);
+    if (dd->dd_fd < 0)
     {
-        dd_close(dd);
-        return NULL;
+        perror_msg("Can't open newly created directory '%s'", dir);
+        goto fail;
+    }
+
+    struct stat stat_sb;
+    if (fstat(dd->dd_fd, &stat_sb) < 0)
+    {
+        perror_msg("stat(%s)", dd->dd_dirname);
+        goto fail;
     }
 
+    if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)
+        goto fail;
+
     /* mkdir's mode (above) can be affected by umask, fix it */
-    if (chmod(dir, dir_mode) == -1)
+    if (fchmod(dd->dd_fd, dir_mode) == -1)
     {
         perror_msg("Can't change mode of '%s'", dir);
-        dd_close(dd);
-        return NULL;
+        goto fail;
     }
 
     dd->dd_uid = (uid_t)-1L;
@@ -467,6 +584,10 @@ struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int
     }
 
     return dd;
+
+fail:
+    dd_close(dd);
+    return NULL;
 }
 
 /* Resets ownership of the given directory to UID and GID according to values
@@ -474,7 +595,7 @@ struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int
  */
 int dd_reset_ownership(struct dump_dir *dd)
 {
-    const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);
+    const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);
     if (r < 0)
     {
         perror_msg("Can't change '%s' ownership to %lu:%lu", dd->dd_dirname,
@@ -573,59 +694,39 @@ void dd_sanitize_mode_and_owner(struct dump_dir *dd)
     if (!dd->locked)
         error_msg_and_die("dump_dir is not opened"); /* bug */
 
-    DIR *d = opendir(dd->dd_dirname);
-    if (!d)
-        return;
-
-    struct dirent *dent;
-    while ((dent = readdir(d)) != NULL)
+    dd_init_next_file(dd);
+    char *short_name;
+    while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))
     {
-        if (dent->d_name[0] == '.') /* ".lock", ".", ".."? skip */
-            continue;
-        char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);
-        struct stat statbuf;
-        if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
-        {
-            if ((statbuf.st_mode & 0777) != dd->mode)
-            {
-                /* We open the file only for fchmod()
-                 *
-                 * We use fchmod() because chmod() changes the permissions of
-                 * the file specified whose pathname is given in path, which
-                 * is dereferenced if it is a symbolic link.
-                 */
-                int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);
-                if (fd >= 0)
-                {
-                    if (fchmod(fd, dd->mode) != 0)
-                    {
-                        perror_msg("Can't change '%s' mode to 0%o", full_path,
-                                   (unsigned)dd->mode);
-                    }
-                    close(fd);
-                }
-                else
-                {
-                    perror_msg("Can't open regular file '%s'", full_path);
-                }
-            }
-            if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)
-            {
-                if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)
-                {
-                    perror_msg("Can't change '%s' ownership to %lu:%lu", full_path,
-                               (long)dd->dd_uid, (long)dd->dd_gid);
-                }
-            }
-        }
-        free(full_path);
+        /* The current process has to have read access at least */
+        int fd = secure_openat_read(dd->dd_fd, short_name);
+        if (fd < 0)
+            goto next;
+
+        if (fchmod(fd, dd->mode) != 0)
+            perror_msg("Can't change '%s/%s' mode to 0%o", dd->dd_dirname, short_name,
+                       (unsigned)dd->mode);
+
+        if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)
+            perror_msg("Can't change '%s/%s' ownership to %lu:%lu", dd->dd_dirname, short_name,
+                       (long)dd->dd_uid, (long)dd->dd_gid);
+
+        close(fd);
+next:
+        free(short_name);
     }
-    closedir(d);
 }
 
-static int delete_file_dir(const char *dir, bool skip_lock_file)
+static int delete_file_dir(int dir_fd, bool skip_lock_file)
 {
-    DIR *d = opendir(dir);
+    int opendir_fd = dup(dir_fd);
+    if (opendir_fd < 0)
+    {
+        perror_msg("delete_file_dir: dup(dir_fd)");
+        return -1;
+    }
+
+    DIR *d = fdopendir(opendir_fd);
     if (!d)
     {
         /* The caller expects us to error out only if the directory
@@ -651,26 +752,35 @@ static int delete_file_dir(const char *dir, bool skip_lock_file)
             unlink_lock_file = true;
             continue;
         }
-        char *full_path = concat_path_file(dir, dent->d_name);
-        if (unlink(full_path) == -1 && errno != ENOENT)
+        if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)
         {
             int err = 0;
             if (errno == EISDIR)
             {
                 errno = 0;
-                err = delete_file_dir(full_path, /*skip_lock_file:*/ false);
+                int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);
+                if (subdir_fd < 0)
+                {
+                    perror_msg("Can't open sub-dir'%s'", dent->d_name);
+                    closedir(d);
+                    return -1;
+                }
+                else
+                {
+                    err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);
+                    close(subdir_fd);
+                    if (err == 0)
+                        unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);
+                }
             }
             if (errno || err)
             {
-                perror_msg("Can't remove '%s'", full_path);
-                free(full_path);
+                perror_msg("Can't remove '%s'", dent->d_name);
                 closedir(d);
                 return -1;
             }
         }
-        free(full_path);
     }
-    closedir(d);
 
     /* Here we know for sure that all files/subdirs we found via readdir
      * were deleted successfully. If rmdir below fails, we assume someone
@@ -678,42 +788,52 @@ static int delete_file_dir(const char *dir, bool skip_lock_file)
      */
 
     if (unlink_lock_file)
-    {
-        char *full_path = concat_path_file(dir, ".lock");
-        xunlink(full_path);
-        free(full_path);
-
-        unsigned cnt = RMDIR_FAIL_COUNT;
-        do {
-            if (rmdir(dir) == 0)
-                return 0;
-            /* Someone locked the dir after unlink, but before rmdir.
-             * This "someone" must be dd_lock().
-             * It detects this (by seeing that there is no time file)
-             * and backs off at once. So we need to just retry rmdir,
-             * with minimal sleep.
-             */
-            usleep(RMDIR_FAIL_USLEEP);
-        } while (--cnt != 0);
-    }
+        xunlinkat(dir_fd, ".lock", /*only files*/0);
 
-    int r = rmdir(dir);
-    if (r)
-        perror_msg("Can't remove directory '%s'", dir);
-    return r;
+    closedir(d);
+    return 0;
 }
 
 int dd_delete(struct dump_dir *dd)
 {
-    int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);
+    if (!dd->locked)
+    {
+        error_msg("unlocked problem directory %s cannot be deleted", dd->dd_dirname);
+        return -1;
+    }
+
+    if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)
+    {
+        perror_msg("Can't remove contents of directory '%s'", dd->dd_dirname);
+        return -2;
+    }
+
+    unsigned cnt = RMDIR_FAIL_COUNT;
+    do {
+        if (rmdir(dd->dd_dirname) == 0)
+            break;
+        /* Someone locked the dir after unlink, but before rmdir.
+         * This "someone" must be dd_lock().
+         * It detects this (by seeing that there is no time file)
+         * and backs off at once. So we need to just retry rmdir,
+         * with minimal sleep.
+         */
+        usleep(RMDIR_FAIL_USLEEP);
+    } while (--cnt != 0);
+
+    if (cnt == 0)
+    {
+        perror_msg("Can't remove directory '%s'", dd->dd_dirname);
+        return -3;
+    }
+
     dd->locked = 0; /* delete_file_dir already removed .lock */
     dd_close(dd);
-    return r;
+    return 0;
 }
 
-static char *load_text_file(const char *path, unsigned flags)
+static char *load_text_from_file_descriptor(int fd, const char *path, int flags)
 {
-    int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));
     if (fd == -1)
     {
         if (!(flags & DD_FAIL_QUIETLY_ENOENT))
@@ -768,14 +888,30 @@ static char *load_text_file(const char *path, unsigned flags)
     return strbuf_free_nobuf(buf_content);
 }
 
-static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)
+static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)
 {
+    assert(name[0] != '/');
+
+    const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));
+    return load_text_from_file_descriptor(fd, name, flags);
+}
+
+static char *load_text_file(const char *path, unsigned flags)
+{
+    const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));
+    return load_text_from_file_descriptor(fd, path, flags);
+}
+
+static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)
+{
+    assert(name[0] != '/');
+
     /* the mode is set by the caller, see dd_create() for security analysis */
-    unlink(path);
-    int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);
+    unlinkat(dir_fd, name, /*remove only files*/0);
+    int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);
     if (fd < 0)
     {
-        perror_msg("Can't open file '%s'", path);
+        perror_msg("Can't open file '%s'", name);
         return false;
     }
 
@@ -783,15 +919,30 @@ static bool save_binary_file(const char *path, const char* data, unsigned size,
     {
         if (fchown(fd, uid, gid) == -1)
         {
-            perror_msg("Can't change '%s' ownership to %lu:%lu", path, (long)uid, (long)gid);
+            perror_msg("Can't change '%s' ownership to %lu:%lu", name, (long)uid, (long)gid);
+            close(fd);
+            return false;
         }
     }
 
+    /* O_CREATE in the open() call above causes that the permissions of the
+     * created file are (mode & ~umask)
+     *
+     * This is true only if we did create file. We are not sure we created it
+     * in this case - it may exist already.
+     */
+    if (fchmod(fd, mode) == -1)
+    {
+        perror_msg("Can't change mode of '%s'", name);
+        close(fd);
+        return false;
+    }
+
     unsigned r = full_write(fd, data, size);
     close(fd);
     if (r != size)
     {
-        error_msg("Can't save file '%s'", path);
+        error_msg("Can't save file '%s'", name);
         return false;
     }
 
@@ -814,11 +965,7 @@ char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned fla
     if (strcmp(name, "release") == 0)
         name = FILENAME_OS_RELEASE;
 
-    char *full_path = concat_path_file(dd->dd_dirname, name);
-    char *ret = load_text_file(full_path, flags);
-    free(full_path);
-
-    return ret;
+    return load_text_file_at(dd->dd_fd, name, flags);
 }
 
 char* dd_load_text(const struct dump_dir *dd, const char *name)
@@ -834,9 +981,7 @@ void dd_save_text(struct dump_dir *dd, const char *name, const char *data)
     if (!str_is_correct_filename(name))
         error_msg_and_die("Cannot save text. '%s' is not a valid file name", name);
 
-    char *full_path = concat_path_file(dd->dd_dirname, name);
-    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);
-    free(full_path);
+    save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);
 }
 
 void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)
@@ -847,12 +992,9 @@ void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, uns
     if (!str_is_correct_filename(name))
         error_msg_and_die("Cannot save binary. '%s' is not a valid file name", name);
 
-    char *full_path = concat_path_file(dd->dd_dirname, name);
-    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);
-    free(full_path);
+    save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);
 }
 
-
 int dd_delete_item(struct dump_dir *dd, const char *name)
 {
     if (!dd->locked)
@@ -861,18 +1003,16 @@ int dd_delete_item(struct dump_dir *dd, const char *name)
     if (!str_is_correct_filename(name))
         error_msg_and_die("Cannot delete item. '%s' is not a valid file name", name);
 
-    char *path = concat_path_file(dd->dd_dirname, name);
-    int res = unlink(path);
+    int res = unlinkat(dd->dd_fd, name, /*only files*/0);
 
     if (res < 0)
     {
         if (errno == ENOENT)
             res = 0;
         else
-            perror_msg("Can't delete file '%s'", path);
+            perror_msg("Can't delete file '%s'", name);
     }
 
-    free(path);
     return res;
 }
 
@@ -880,11 +1020,17 @@ DIR *dd_init_next_file(struct dump_dir *dd)
 {
 //    if (!dd->locked)
 //        error_msg_and_die("dump_dir is not opened"); /* bug */
+    int opendir_fd = dup(dd->dd_fd);
+    if (opendir_fd < 0)
+    {
+        perror_msg("dd_init_next_file: dup(dd_fd)");
+        return NULL;
+    }
 
     if (dd->next_dir)
         closedir(dd->next_dir);
 
-    dd->next_dir = opendir(dd->dd_dirname);
+    dd->next_dir = fdopendir(opendir_fd);
     if (!dd->next_dir)
     {
         error_msg("Can't open directory '%s'", dd->dd_dirname);
@@ -901,7 +1047,7 @@ int dd_get_next_file(struct dump_dir *dd, char **short_name, char **full_name)
     struct dirent *dent;
     while ((dent = readdir(dd->next_dir)) != NULL)
     {
-        if (is_regular_file(dent, dd->dd_dirname))
+        if (is_regular_file_at(dent, dd->dd_fd))
         {
             if (short_name)
                 *short_name = xstrdup(dent->d_name);
@@ -943,7 +1089,6 @@ report_result_t *find_in_reported_to(struct dump_dir *dd, const char *prefix)
     return result;
 }
 
-
 /* Utility function */
 
 void delete_dump_dir(const char *dirname)
diff --git a/src/lib/problem_data.c b/src/lib/problem_data.c
index e80569a..b7b228c 100644
--- a/src/lib/problem_data.c
+++ b/src/lib/problem_data.c
@@ -228,14 +228,14 @@ static const char *const always_text_files[] = {
     FILENAME_BACKTRACE,
     NULL
 };
-static char* is_text_file(const char *name, ssize_t *sz)
+static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)
 {
     /* We were using magic.h API to check for file being text, but it thinks
      * that file containing just "0" is not text (!!)
      * So, we do it ourself.
      */
 
-    int fd = open(name, O_RDONLY);
+    int fd = secure_openat_read(dir_fd, name);
     if (fd < 0)
         return NULL; /* it's not text (because it does not exist! :) */
 
@@ -324,7 +324,7 @@ void load_problem_data_from_dump_dir(problem_data_t *problem_data, struct dump_d
 
         if (!editable)
         {
-            text = is_text_file(full_name, &sz);
+            text = is_text_file_at(dd->dd_fd, short_name, &sz);
             if (!text)
             {
                 add_to_problem_data_ext(problem_data,
diff --git a/src/lib/xfuncs.c b/src/lib/xfuncs.c
index c8f93a8..5a53b73 100644
--- a/src/lib/xfuncs.c
+++ b/src/lib/xfuncs.c
@@ -331,6 +331,12 @@ int xopen(const char *pathname, int flags)
     return xopen3(pathname, flags, 0666);
 }
 
+void xunlinkat(int dir_fd, const char *pathname, int flags)
+{
+    if (unlinkat(dir_fd, pathname, flags))
+        perror_msg_and_die("Can't remove file '%s'", pathname);
+}
+
 void xunlink(const char *pathname)
 {
     if (unlink(pathname))
@@ -359,21 +365,29 @@ int open_or_warn(const char *pathname, int flags)
  * do not report the type, they report DT_UNKNOWN for every dirent
  * (and this is not a bug in filesystem, this is allowed by standards).
  */
-int is_regular_file(struct dirent *dent, const char *dirname)
+int is_regular_file_at(struct dirent *dent, int dir_fd)
 {
     if (dent->d_type == DT_REG)
         return 1;
     if (dent->d_type != DT_UNKNOWN)
         return 0;
 
-    char *fullname = xasprintf("%s/%s", dirname, dent->d_name);
     struct stat statbuf;
-    int r = lstat(fullname, &statbuf);
-    free(fullname);
+    int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);
 
     return r == 0 && S_ISREG(statbuf.st_mode);
 }
 
+int is_regular_file(struct dirent *dent, const char *dirname)
+{
+    int dir_fd = open(dirname, O_DIRECTORY);
+    if (dir_fd < 0)
+        return 0;
+    int r = is_regular_file_at(dent, dir_fd);
+    close(dir_fd);
+    return r;
+}
+
 /* Is it "." or ".."? */
 /* abrtlib candidate */
 bool dot_or_dotdot(const char *filename)
-- 
1.8.3.1

