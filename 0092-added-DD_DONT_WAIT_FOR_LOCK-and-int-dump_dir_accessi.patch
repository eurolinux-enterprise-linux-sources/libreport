From fc0047883c81f2025f34d26acff9667b95a35e13 Mon Sep 17 00:00:00 2001
From: Jiri Moskovcak <jmoskovc@redhat.com>
Date: Fri, 10 May 2013 12:42:54 +0200
Subject: [RHEL6 LIBREPORT PATCH 92/94] added DD_DONT_WAIT_FOR_LOCK and int
 dump_dir_accessible_by_uid() - rhbz#961231

Signed-off-by: Jiri Moskovcak <jmoskovc@redhat.com>
Signed-off-by: Jakub Filak <jfilak@redhat.com>
---
 src/include/dump_dir.h | 14 +++++++++----
 src/lib/dump_dir.c     | 55 +++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 64 insertions(+), 5 deletions(-)

diff --git a/src/include/dump_dir.h b/src/include/dump_dir.h
index 8f34f2f..26a161b 100644
--- a/src/include/dump_dir.h
+++ b/src/include/dump_dir.h
@@ -35,6 +35,8 @@ enum {
     /* Open symlinks. dd_* funcs don't open symlinks by default */
     DD_OPEN_FOLLOW = (1 << 2),
     DD_OPEN_READONLY = (1 << 3),
+    DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE = (1 << 4),
+    DD_DONT_WAIT_FOR_LOCK = (1 << 5),
 };
 
 struct dump_dir {
@@ -62,10 +64,6 @@ void dd_sanitize_mode_and_owner(struct dump_dir *dd);
 DIR *dd_init_next_file(struct dump_dir *dd);
 int dd_get_next_file(struct dump_dir *dd, char **short_name, char **full_name);
 
-enum {
-    /* DD_FAIL_QUIETLY_ENOENT bit is valid for dd_load_text_ext too, */
-    DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE = (DD_OPEN_READONLY << 1),
-};
 char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags);
 char* dd_load_text(const struct dump_dir *dd, const char *name);
 void dd_save_text(struct dump_dir *dd, const char *name, const char *data);
@@ -93,6 +91,14 @@ report_result_t *find_in_reported_to(struct dump_dir *dd, const char *prefix);
 
 
 void delete_dump_dir(const char *dirname);
+/* Checks dump dir accessibility for particular uid.
+ *
+ * If the directory doesn't exist the directory is not accessible and errno is
+ * set to ENOTDIR.
+ *
+ * Returns non zero if dump dir is accessible otherwise return 0 value.
+ */
+int dump_dir_accessible_by_uid(const char *dirname, uid_t uid);
 
 #ifdef __cplusplus
 }
diff --git a/src/lib/dump_dir.c b/src/lib/dump_dir.c
index d271145..ce31cc0 100644
--- a/src/lib/dump_dir.c
+++ b/src/lib/dump_dir.c
@@ -213,7 +213,7 @@ static int dd_lock(struct dump_dir *dd, unsigned sleep_usec, int flags)
             strcpy(lock_buf + dirname_len, "/.lock");
             xunlink(lock_buf);
             VERB1 log("Unlocked '%s' (no time file)", lock_buf);
-            if (--count == 0)
+            if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)
             {
                 errno = EISDIR; /* "this is an ordinary dir, not dump dir" */
                 return -1;
@@ -931,3 +931,56 @@ void delete_dump_dir(const char *dirname)
         dd_delete(dd);
     }
 }
+
+#if DUMP_DIR_OWNED_BY_USER == 0
+static bool uid_in_group(uid_t uid, gid_t gid)
+{
+    char **tmp;
+    struct passwd *pwd = getpwuid(uid);
+
+    if (!pwd)
+        return FALSE;
+
+    if (pwd->pw_gid == gid)
+        return TRUE;
+
+    struct group *grp = getgrgid(gid);
+    if (!(grp && grp->gr_mem))
+        return FALSE;
+
+    for (tmp = grp->gr_mem; *tmp != NULL; tmp++)
+    {
+        if (g_strcmp0(*tmp, pwd->pw_name) == 0)
+        {
+            VERB3 log("user %s belongs to group: %s",  pwd->pw_name, grp->gr_name);
+            return TRUE;
+        }
+    }
+
+    VERB2 log("user %s DOESN'T belong to group: %s",  pwd->pw_name, grp->gr_name);
+    return FALSE;
+}
+#endif
+
+int dump_dir_accessible_by_uid(const char *dirname, uid_t uid)
+{
+    struct stat statbuf;
+    if (stat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
+        errno = ENOTDIR;
+    else
+    {
+        errno = 0;
+
+#if DUMP_DIR_OWNED_BY_USER > 0
+        if (uid == 0 || (statbuf.st_mode & S_IROTH) || uid == statbuf.st_uid)
+#else
+        if (uid == 0 || (statbuf.st_mode & S_IROTH) || uid_in_group(uid, statbuf.st_gid))
+#endif
+        {
+            VERB1 log("directory '%s' is accessible by %ld uid", dirname, (long)uid);
+            return 1;
+        }
+    }
+
+    return 0;
+}
-- 
1.8.2.1

