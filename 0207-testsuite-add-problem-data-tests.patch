From 7d2e32e588857ebbd5360ae24ac8f7079971c095 Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Fri, 15 Jan 2016 17:27:50 +0100
Subject: [PATCH] testsuite: add problem data tests

---
 tests/Makefile.am         |    3 +-
 tests/helpers/testsuite.h |    4 +-
 tests/problem_data.at     |  328 +++++++++++++++++++++++++++++++++++++++++++++
 tests/testsuite.at        |    1 +
 4 files changed, 333 insertions(+), 3 deletions(-)
 create mode 100644 tests/problem_data.at

diff --git a/tests/Makefile.am b/tests/Makefile.am
index 47d532a..e4cdf01 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -38,7 +38,8 @@ TESTSUITE_AT = \
   ureport.at \
   dump_dir.at \
   global_config.at \
-  event_config.at
+  event_config.at \
+  problem_data.at
 
 TESTSUITE_AT_IN = \
   bugzilla_plugin.at
diff --git a/tests/helpers/testsuite.h b/tests/helpers/testsuite.h
index 956dde7..28bfd3e 100644
--- a/tests/helpers/testsuite.h
+++ b/tests/helpers/testsuite.h
@@ -265,8 +265,8 @@ FILE *g_testsuite_output_stream = 0;
 
 #define TS_ASSERT_PTR_OP_MESSAGE(actual, operator, expected, message) \
     do { \
-        void *l_ts_lhs = (actual); \
-        void *l_ts_rhs = (expected); \
+        const void *l_ts_lhs = (actual); \
+        const void *l_ts_rhs = (expected); \
         if (l_ts_lhs operator l_ts_rhs) { \
             TS_SUCCESS("%s ("#actual" "#operator" "#expected")\n\tActual  : %p\n", message ? message : "Assert", l_ts_lhs); \
         } \
diff --git a/tests/problem_data.at b/tests/problem_data.at
new file mode 100644
index 0000000..50e25de
--- /dev/null
+++ b/tests/problem_data.at
@@ -0,0 +1,328 @@
+# -*- Autotest -*-
+
+AT_BANNER([problem data])
+
+## ---------------- ##
+## add_to_problem_data ##
+## ---------------- ##
+
+AT_TESTFUN([add_to_problem_data],
+[[
+#include "problem_data.h"
+#include "internal_libreport.h"
+#include <assert.h>
+
+#define TEST_NAME "package"
+#define TEST_CONTENTS "libreport"
+#define TEST_FLAGS (CD_FLAG_TXT | CD_FLAG_ISNOTEDITABLE)
+
+int main(int argc, char **argv)
+{
+    g_verbose = 3;
+
+    problem_data_t *data = new_problem_data();
+    add_to_problem_data(data, TEST_NAME, TEST_CONTENTS);
+
+    struct problem_item *itm = get_problem_data_item_or_NULL(data, TEST_NAME);
+
+    assert(strcmp(itm->content, TEST_CONTENTS) == 0);
+    assert(itm->flags == TEST_FLAGS);
+
+    free_problem_data(data);
+
+    return 0;
+}
+]])
+
+## -------------------- ##
+## add_to_problem_data_ext ##
+## -------------------- ##
+
+AT_TESTFUN([add_to_problem_data_ext],
+[[
+#include "problem_data.h"
+#include "internal_libreport.h"
+#include <assert.h>
+
+#define TEST_NAME "package"
+#define TEST_CONTENTS "libreport"
+#define TEST_FLAGS (CD_FLAG_TXT | CD_FLAG_ISNOTEDITABLE | CD_FLAG_UNIXTIME)
+
+int main(int argc, char **argv)
+{
+    g_verbose = 3;
+
+    problem_data_t *data = new_problem_data();
+
+    add_to_problem_data_ext(data, TEST_NAME, TEST_CONTENTS, TEST_FLAGS);
+    struct problem_item *found = get_problem_data_item_or_NULL(data, TEST_NAME);
+    assert(found != NULL);
+
+    assert(strcmp(found->content, TEST_CONTENTS) == 0);
+    assert(found->flags == TEST_FLAGS);
+
+    free_problem_data(data);
+
+    return 0;
+}
+]])
+
+
+## ------------------------------- ##
+## load_problem_data_from_dump_dir ##
+## ------------------------------- ##
+
+AT_TESTFUN([load_problem_data_from_dump_dir],
+[[
+#include "problem_data.h"
+#include "internal_libreport.h"
+#include <assert.h>
+
+int main(int argc, char **argv)
+{
+    g_verbose = 3;
+
+    char template[] = "/tmp/XXXXXX";
+
+    if (mkdtemp(template) == NULL) {
+        perror("mkdtemp()");
+        return EXIT_FAILURE;
+    }
+
+    printf("Dump dir path: %s\n", template);
+
+    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
+    assert(dd != NULL || !"Cannot create new dump directory");
+
+    /* dd_create_basic_files() should create these files:
+       FILENAME_TIME, FILENAME_LAST_OCCURRENCE, FILENAME_UID, FILENAME_KERNEL,
+       FILENAME_ARCHITECTURE, FILENAME_HOSTNAME, FILENAME_OS_INFO, FILENAME_OS_RELEASE
+     */
+    dd_create_basic_files(dd, geteuid(), NULL);
+
+    dd_save_text(dd, FILENAME_TYPE, "attest");
+    dd_save_text(dd, FILENAME_ANALYZER, "attest-problem_data");
+    dd_save_text(dd, FILENAME_DUPHASH, "0123456789ABCDEF");
+    dd_save_text(dd, FILENAME_UUID, "FEDCBA9876543210");
+    dd_save_text(dd, FILENAME_USERNAME, "perhaps_tester");
+    dd_save_text(dd, FILENAME_PACKAGE, "1:attest-1.1-3.x86_64");
+    dd_save_text(dd, FILENAME_PKG_EPOCH, "1");
+    dd_save_text(dd, FILENAME_PKG_NAME, "attest");
+    dd_save_text(dd, FILENAME_PKG_VERSION, "1.1");
+    dd_save_text(dd, FILENAME_PKG_RELEASE, "3");
+    dd_save_text(dd, FILENAME_PKG_ARCH, "x86_64");
+    dd_save_text(dd, FILENAME_CMDLINE, "$TESTSUITE.DIR/$NUM/load_problem_data_from_dump_dir foo blah");
+    dd_save_text(dd, FILENAME_EXECUTABLE, "$TESTSUITE.DIR/$NUM/load_problem_data_from_dump_dir");
+    dd_save_text(dd, FILENAME_ROOTDIR, "/");
+    dd_save_text(dd, FILENAME_PWD, "$TESTSUITE.DIR");
+    dd_save_text(dd, FILENAME_PID, "12345");
+    dd_save_text(dd, FILENAME_COUNT, "1");
+    dd_save_text(dd, FILENAME_REASON, "Unit testing load_problem_data_from_dump_dir");
+    dd_save_text(dd, FILENAME_COMMENT, "Random comment");
+    dd_save_text(dd, FILENAME_BACKTRACE, "Pseudo-backtrace");
+    dd_save_text(dd, FILENAME_OPEN_FDS, "Opened FDs");
+    dd_save_text(dd, FILENAME_MAPS, "/proc/[pid]/maps");
+    dd_save_text(dd, FILENAME_SMAPS, "/proc/[pid]/smaps");
+    dd_save_text(dd, FILENAME_ENVIRON, "/proc/[pid]/environ");
+    dd_save_text(dd, FILENAME_LIMITS, "/proc/[pid]/limits");
+    dd_save_text(dd, FILENAME_CGROUP, "/proc/[pid]/cgroup");
+    dd_save_text(dd, FILENAME_PROC_PID_STATUS, "/proc/[pid]/status");
+    dd_save_text(dd, FILENAME_CRASH_FUNCTION, "main");
+    dd_save_text(dd, FILENAME_REMOTE, "0");
+    dd_save_text(dd, FILENAME_RATING, "4");
+    dd_save_text(dd, FILENAME_TAINTED, "Not tainted");
+    dd_save_text(dd, FILENAME_TAINTED_SHORT, "Not tainted");
+    dd_save_text(dd, FILENAME_TAINTED_LONG, "Not tainted");
+    dd_save_text(dd, FILENAME_NOT_REPORTABLE, "Despite 'not tainted' this problem cannot be reported.");
+    dd_save_text(dd, FILENAME_REPORTED_TO, "Bugzilla: URL=https://bugzilla.redhat.com/1000000");
+    dd_save_text(dd, FILENAME_EVENT_LOG, "--- report_Bugzilla has finished successfully ---");
+
+    dd_save_text(dd, FILENAME_KERNEL_LOG, "FILENAME_KERNEL_LOG");
+    dd_save_text(dd, FILENAME_DESCRIPTION, "FILENAME_DESCRIPTION");
+    dd_save_text(dd, FILENAME_CORE_BACKTRACE, "FILENAME_CORE_BACKTRACE");
+    dd_save_text(dd, FILENAME_REMOTE_RESULT, "FILENAME_REMOTE_RESULT");
+    dd_save_text(dd, FILENAME_ABRT_VERSION, "FILENAME_ABRT_VERSION");
+
+    dd_save_text(dd, "attestsuite-random-file", "random content");
+    dd_save_text(dd, "attestsuite-oneliner-newline", "newline\n");
+    dd_save_text(dd, "attestsuite-newline-followed", "newline\nfollowed");
+    dd_save_text(dd, "attestsuite-multi-line", "newline\nextra\n");
+    dd_save_text(dd, "attestsuite-tab", "tab\ttab");
+    dd_save_text(dd, "attestsuite-cr", "cr\rcr");
+
+    char buffer[1024*3];
+    memset(buffer, 'x', sizeof(buffer));
+
+    {
+        int fd4k = openat(dd->dd_fd, "attestsuite-over4k", O_WRONLY | O_CREAT | O_TRUNC, 0550);
+        assert(fd4k >= 0);
+        full_write(fd4k, buffer, sizeof(buffer));
+        full_write(fd4k, buffer, sizeof(buffer));
+        close(fd4k);
+    }
+
+    {
+        int bigfd = openat(dd->dd_fd, "attestsuite-bigtext", O_WRONLY | O_CREAT | O_TRUNC, 0550);
+        assert(bigfd >= 0);
+        for (int i = 3000; i > 0; --i)
+            full_write(bigfd, buffer, sizeof(buffer));
+        close(bigfd);
+    }
+
+    char *dst;
+
+    dst = concat_path_file(dd->dd_dirname, FILENAME_BINARY);
+    copy_file_recursive("/bin/sh", dst);
+    free(dst);
+
+    dst = concat_path_file(dd->dd_dirname, FILENAME_COREDUMP);
+    copy_file_recursive("/bin/sh", dst);
+    free(dst);
+
+    dst = concat_path_file(dd->dd_dirname, FILENAME_VMCORE);
+    copy_file_recursive("/bin/sh", dst);
+    free(dst);
+
+    static const char *const list_elements[] = { FILENAME_UID, FILENAME_PACKAGE,
+        FILENAME_EXECUTABLE, FILENAME_TIME, FILENAME_COUNT };
+
+    static const char *const editable_files[] = { FILENAME_COMMENT, FILENAME_BACKTRACE,
+        FILENAME_REASON, FILENAME_OPEN_FDS, FILENAME_CMDLINE, FILENAME_MAPS,
+        FILENAME_SMAPS, FILENAME_ENVIRON, FILENAME_HOSTNAME, FILENAME_REMOTE, };
+
+    static const char *const binary_files[] = { FILENAME_BINARY, FILENAME_COREDUMP,
+        FILENAME_VMCORE, };
+
+    problem_data_t *pd = new_problem_data();
+    load_problem_data_from_dump_dir(pd, dd, /*excluding*/NULL);
+
+    GHashTableIter pd_iter;
+    char *element_name;
+    struct problem_item *item;
+    g_hash_table_iter_init(&pd_iter, pd);
+    while (g_hash_table_iter_next(&pd_iter, (void**)&element_name, (void**)&item))
+    {
+        printf("Testing element : %s\n", element_name);
+
+        size_t i;
+        for (i = 0; i < ARRAY_SIZE(list_elements); ++i)
+        {
+            if (strcmp(element_name, list_elements[i]) == 0)
+            {
+                assert((item->flags & CD_FLAG_LIST));
+                break;
+            }
+        }
+        if (i == ARRAY_SIZE(list_elements))
+            assert(!(item->flags & CD_FLAG_LIST));
+
+        for (i = 0; i < ARRAY_SIZE(editable_files); ++i)
+        {
+            if (strcmp(element_name, editable_files[i]) == 0)
+            {
+                assert((item->flags & CD_FLAG_ISEDITABLE) && !(item->flags & CD_FLAG_ISNOTEDITABLE));
+                break;
+            }
+        }
+        if (i == ARRAY_SIZE(editable_files))
+            assert(!(item->flags & CD_FLAG_ISEDITABLE) && (item->flags & CD_FLAG_ISNOTEDITABLE));
+
+        for (i = 0; i < ARRAY_SIZE(binary_files); ++i)
+        {
+            if (strcmp(element_name, binary_files[i]) == 0)
+            {
+                assert((item->flags & CD_FLAG_BIN) && !(item->flags & CD_FLAG_TXT));
+                break;
+            }
+        }
+        if (i == ARRAY_SIZE(binary_files))
+        {
+            if(strstr(element_name, "bigtext") == 0)
+                assert((item->flags & CD_FLAG_TXT) && !(item->flags & CD_FLAG_BIN));
+            else
+                assert((item->flags & CD_FLAG_BIN) && !(item->flags & CD_FLAG_TXT));
+        }
+
+        if (strcmp(element_name, FILENAME_TIME) == 0)
+            assert(item->flags & CD_FLAG_UNIXTIME);
+        else
+            assert(!(item->flags & CD_FLAG_UNIXTIME));
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-oneliner-newline");
+        assert(cnt != NULL && "attestsuite-oneliner-newline");
+        assert(strcmp(cnt, "newline") == 0);
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-newline-followed");
+        assert(cnt != NULL && "attestsuite-newline-followed");
+        assert(strcmp(cnt, "newline\nfollowed") == 0);
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-multi-line");
+        assert(cnt != NULL && "attestsuite-multi-line");
+        assert(strcmp(cnt, "newline\nextra\n") == 0);
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-over4k");
+        assert(cnt != NULL && "attestsuite-over4k");
+        assert(strlen(cnt) == (2 * sizeof(buffer)));
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-tab");
+        assert(cnt != NULL && "attestsuite-tab");
+        assert(strcmp(cnt, "tab\ttab") == 0);
+    }
+
+    {
+        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-cr");
+        assert(cnt != NULL && "attestsuite-cr");
+        assert(strcmp(cnt, "cr[0D]cr") == 0);
+    }
+
+    return 0;
+}
+]])
+
+## ------------------------- ##
+## problem_data_reproducible ##
+## ------------------------- ##
+
+AT_TESTFUN([problem_data_reproducible],
+[[
+#include "testsuite.h"
+TS_MAIN
+{
+    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(-1), "Invalid value");
+    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_UNKNOWN));
+    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_YES));
+    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_RECURRENT));
+    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_), "Upper boundary");
+    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_ + 1), "Upper boundary + 1");
+    TS_ASSERT_SIGNED_EQ(_PROBLEM_REPRODUCIBLE_MAX_, 3);
+
+    problem_data_t *pd = new_problem_data();
+
+    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), -1);
+
+    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_UNKNOWN));
+    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_UNKNOWN);
+
+    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_YES));
+    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_YES);
+
+    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_RECURRENT));
+    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_RECURRENT);
+
+    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_));
+    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), -1);
+
+    free_problem_data(pd);
+}
+TS_RETURN_MAIN
+]])
diff --git a/tests/testsuite.at b/tests/testsuite.at
index 04dbe3f..7a35838 100644
--- a/tests/testsuite.at
+++ b/tests/testsuite.at
@@ -14,3 +14,4 @@ m4_include([dump_dir.at])
 m4_include([event_config.at])
 m4_include([global_config.at])
 m4_include([bugzilla_plugin.at])
+m4_include([problem_data.at])
-- 
1.7.1

